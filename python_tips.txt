Типы данных Python

=== Числа (функции работы с числами) ===

round() - округлить число до нужного кличества знаков:
    
    In [9]: round(10/3.0, 2)
    Out[9]: 3.33

int() - выполнить конвертацию в тип int (во втором аргументе можно указывать систему счисления):
    
    In [20]: int(11, 2)
    Out[20]: 3
    
    In [26]: int('ff', 16)
    Out[26]: 255

bin() - получить двоичное представление числа (результат - строка):
    
    In [23]: bin(8)
    Out[23]: '0b1000'

    In [24]: bin(255)
    Out[24]: '0b11111111'


hex() - получить шестнадцатеричное значение:
    
    In [25]: hex(10)
    Out[25]: '0xa'

Для более сложных математических функций в Python есть модуль math:

    In [30]: math.sqrt()
    In [31]: math.factorial()
    In [32]: math.pi

========================================



=== Строки =============================

Строка - последовательность символов, заключенная в кавычки, неизменяемый упорядоченный тип данных

Суммирование строк:
    
    In [14]: intf = 'interface'
    In [15]: tun = 'Tunnel0'
    
    In [16]: intf + tun
    Out[16]: 'interfaceTunnel0'
    
    In [17]: intf + ' ' + tun
    Out[17]: 'interface Tunnel0'
    
Умножение строки на число:
    
    intf * 5
    Out[18]: 'interfaceinterfaceinterfaceinterfaceinterface'
    
    In [19]: '#' * 40
    Out[19]: '########################################'

    
Срез строк (по второе число диапазона не включая его, если не указывается второе число, то срез будет до конца строки):
    
    In [20]: string1 = 'interface FastEthernet1/0'
    
    In [24]: string1[0:9]
    Out[24]: 'interface'
    
    In [26]: string1[10:]
    Out[26]: 'FastEthernet1/0'

Срезать три последних символа строки:
    
    In [27]: string1[-3:]
    Out[27]: '1/0'
    
В срезе можно указывать шаг. Так можно получить нечетные числа:
    
    In [28]: a = '0123456789'
    
    In [29]: a[1::2]
    Out[29]: '13579'
    
Четные числа:
    
    In [31]: a[::2]
    Out[31]: '02468'

Получить строку в обратном порядке:
    
    In [28]: a = '0123456789'
    
    In [29]: a[::]
    Out[29]: '0123456789'
    
    In [30]: a[::-1]
    Out[30]: '9876543210'
    
len() - получить количество символов в строке (функция)

upper(), lower(), swapcase(), capitalize() - методы преобразования регистра

сount() - метод подсчета того, сколько раз символ или подстрока присутствует в строке:
    
    In [33]: string1 = 'Hello, hello, hello, hello'
    
    In [34]: string1.count('hello')
    Out[34]: 3
    
    In [35]: string1.count('ello')
    Out[35]: 4
    
    In [36]: string1.count('l')
    Out[36]: 8

find() - метод определения позиции символа/подстроки в строке (первого совпадения). Если совпадение не найдено, метод find возвращает -1:
    
    In [37]: string1 = 'interface FastEthernet0/1'
    
    In [38]: string1.find('Fast')
    Out[38]: 10
    
    In [39]: string1[string1.find('Fast')::]
    Out[39]: 'FastEthernet0/1'
    
    Если совпадение не найдено, метод find возвращает -1.

startswith(), endswith() - методы проверки на то, начинается или заканчивается ли строка на определенные символы:
    
    In [40]: string1 = 'FastEthernet0/1'
    
    In [41]: string1.startswith('Fast')
    Out[41]: True
    
    In [44]: string1.endswith('0/2')
    Out[44]: False

    Методам startswith() и endswith() можно передавать несколько значений (обязательно как кортеж):
    
    In [1]: "test".startswith(("r", "t"))
    Out[1]: True
    
    In [4]: "rtest".endswith(("r", "a"))
    Out[4]: False
    
replace() - метод замены подстроки в строке на подстроку, указанную во втором аргументе:
    
    In [45]: string1 = 'FastEthernet0/1'
    
    In [46]: string1.replace('Fast', 'Gigabit')
    Out[46]: 'GigabitEthernet0/1'
    
strip() - метод, убирающий символы, переданные в аргументе, В НАЧАЛЕ и В КОНЦЕ строки, по умолчанию убирает пробельные символы (\t\n\r\f\v):
    
    In [51]: ad_metric = '[110/1045]'
    In [52]: ad_metric.strip('[]')
    Out[52]: '110/1045'
 
    По умолчанию убирает спецсимволы и в начале, и в конце строки. Если необходимо убрать символы только слева или только справа, можно использовать, соответственно, методы lstrip() и rstrip()

split() - разбивает строку на части, используя как разделитель переданный символ (по умолчанию разбивает по пробельным символам - пробелы, табы, перевод строки, пробельные символы также удаляются в начале и в конце строки):
    
    In [53]: string1 = 'switchport trunk allowed vlan 10,20,30,100-200'
    
    In [54]: commands = string1.split()
    
    In [55]: print(commands)
    ['switchport', 'trunk', 'allowed', 'vlan', '10,20,30,100-200']
    
    In [10]: ip = "192.168.100.1"
    
    In [11]: ip.split(".")
    Out[11]: ['192', '168', '100', '1']

    split() - разбивает строку не по одному пробельному символу, а по любому количеству
    split(' ') - разбивает строку по каждому пробелу в отдельности

=========================================================



=== Форматирование строк методом format() ===============

format() - метод форматирования строк, в качестве аргумента подставляется значение в строку на место символа '{}':

    In [1]: "interface FastEthernet0/{}".format('1')
    Out[1]: 'interface FastEthernet0/1'
    
Вывести данные столбцами одинаковой ширины по 15 символов с выравниванием по правой стороне:

    In [4]: print("{:>15} {:>15} {:>15}".format(a, b, c))

Указать, сколько цифр после запятой выводить

    In [9]: print("{:.3f}".format(10.0/3))
    Out[9]: 3.333

Конвертировать числа в двоичный формат:

    In [11]: '{:b} {:b} {:b} {:b}'.format(192, 100, 1, 1)
    Out[11]: '11000000 1100100 1 1'
    
Дополнить числа нулями, вместо пробелов с шириной столбца 8 символов:

    In [13]: '{:08b} {:08b} {:08b} {:08b}'.format(192, 100, 1, 1)
    Out[13]: '11000000 01100100 00000001 00000001'

В фигурных скобках можно указывать имена. Это позволяет передавать аргументы в любом порядке, а также делает шаблон более понятным:

    In [15]: '{ip}/{mask}'.format(mask=24, ip='10.1.1.1')
    Out[15]: '10.1.1.1/24'

Указание номера аргумента:

    In [16]: '{1}/{0}'.format(24, '10.1.1.1')
    Out[16]: '10.1.1.1/24'

=========================================================



=== Форматрование строк с помощью f-строк ==============

F-строки — это литерал строки с буквой f перед ним. Внутри f-строки в паре фигурных скобок указываются имена переменных, которые надо подставить:

    In [1]: ip = '10.1.1.1'
    
    In [2]: mask = 24
    
    In [3]: f"IP: {ip}, mask: {mask}"
    Out[3]: 'IP: 10.1.1.1, mask: 24'
    
f-строки — это выражение, которое выполняется, а не просто строка, таким образом нельзя сначала написать шаблон, а затем определить переменные, которые используются в шаблоне

Кроме подстановки значений переменных, в фигурных скобках можно писать выражения:

    In [5]: first_name = 'William'
    
    In [6]: second_name = 'Shakespeare'
    
    In [7]: f"{first_name.upper()} {second_name.upper()}"
    Out[7]: 'WILLIAM SHAKESPEARE'

После двоеточия в f-строках можно указывать те же значения, что и при использовании format:

    In [9]: oct1, oct2, oct3, oct4 = [10, 1, 1, 1]
    
    In [10]: print(f'''
	...: IP address:
	...: {oct1:<8} {oct2:<8} {oct3:<8} {oct4:<8}
	...: {oct1:08b} {oct2:08b} {oct3:08b} {oct4:08b}''')

    IP address:
    10 1 1 1
    00001010 00000001 00000001 00000001

=========================================================



=== Список (List) =======================================

Список - это последовательность элементов, разделенных между собой запятой и заключенных в квадратные скобки, изменяемый упорядоченный тип данных

    In [1]: list1 = [10,20,30,77]
    In [2]: list2 = ['one', 'dog', 'seven']
    In [3]: list3 = [1, 20, 4.0, 'word']
    
Создание списков:

    In [1]: vlans = [10, 20, 30, 50]
    
    Создание списка с помощью функции list():
    
    In [2]: list1 = list('router')
    In [3]: print(list1)
    ['r', 'o', 'u', 't', 'e', 'r']

Так как список - это упорядоченный тип данных, то, как и в строках, в списках можно обращаться к элементу по номеру, делать срезы:

    In [4]: list3 = [1, 20, 4.0, 'word']
    
    In [5]: list3[1]
    Out[5]: 20
    
    In [6]: list3[1::]
    Out[6]: [20, 4.0, 'word']
    
    In [8]: list3[::-1]
    Out[8]: ['word', 4.0, 20, 1]

reverse() - метод переворачивания списка:

    In [10]: vlans = ['10', '15', '20', '30', '100-200']
    In [11]: vlans.reverse()
    In [12]: vlans
    Out[12]: ['100-200', '30', '20', '15', '10']
    
Изменить элемент списка:

    In [13]: list3
    Out[13]: [1, 20, 4.0, 'word']
    
    In [14]: list3[0] = 'test'
    
    In [15]: list3
    Out[15]: ['test', 20, 4.0, 'word']

Можно создавать и список списков и обращаться к элементам во вложенных списках:

    In [16]: interfaces = [['FastEthernet0/0', '15.0.15.1', 'YES', 'manual', 'up', 'up'],
	....: ['FastEthernet0/1', '10.0.1.1', 'YES', 'manual', 'up', 'up'],
	....: ['FastEthernet0/2', '10.0.2.1', 'YES', 'manual', 'up', 'down']]
    
    In [17]: interfaces[0][0]
    Out[17]: 'FastEthernet0/0'
    
    In [18]: interfaces[2][0]
    Out[18]: 'FastEthernet0/2'
    
    In [19]: interfaces[2][1]
    Out[19]: '10.0.2.1'

len() - функция, возвращает количество элементов списка

    In [1]: items = [1, 2, 3]
    
    In [2]: len(items)
    Out[2]: 3

sorted() - сортирует элементы списка по возрастанию и возвращает новый список:

    In [1]: names = ['John', 'Michael', 'Antony']
    
    In [2]: sorted(names)
    Out[2]: ['Antony', 'John', 'Michael']

join() - метод, собирающий список в одну СТРОКУ с разделителем, который указан перед join:

    In [16]: vlans = ['10', '20', '30']
    
    In [17]: ','.join(vlans)
    Out[17]: '10,20,30'

append() - метод, добавляющий в конец списка указанный элемент, ничего не возвращает:

    In [18]: vlans = ['10', '20', '30', '100-200']
    
    In [19]: vlans.append('300')
    
    In [20]: vlans
    Out[20]: ['10', '20', '30', '100-200', '300']
    
extend() - метод для объединения списков, изменяет список, к которому применен:

    In [21]: vlans = ['10', '20', '30', '100-200']
    
    In [22]: vlans2 = ['300', '400', '500']
    
    In [23]: vlans.extend(vlans2)
    
    In [24]: vlans
    Out[24]: ['10', '20', '30', '100-200', '300', '400', '500']
    
Суммирование списков:

    In [27]: vlans = ['10', '20', '30', '100-200']
    
    In [28]: vlans2 = ['300', '400', '500']
    
    In [29]: vlans + vlans2
    Out[29]: ['10', '20', '30', '100-200', '300', '400', '500']
    
    Суммирование через переменную result:
    
    In [30]: result = vlans + vlans2
    
    In [31]: result
    Out[31]: ['10', '20', '30', '100-200', '300', '400', '500']

pop() - метод, удаляющий элемент, соответствующий указанному НОМЕРУ в списке, возвращает этот элемент (без указания номера удаляется ПОСЛЕДНИЙ элемент списка):

    In [28]: vlans = ['10', '20', '30', '100-200']
    
    In [29]: vlans.pop(-1)
    Out[29]: '100-200'
    
    In [30]: vlans
    Out[30]: ['10', '20', '30']
    
    Без указания номера удаляется ПОСЛЕДНИЙ элемент списка!
    
remove() - метод, удаляющий указанный элемент, НЕ ВОЗВРАЩАЕТ удаленный элемент:

    In [31]: vlans = ['10', '20', '30', '100-200']
    In [32]: vlans.remove('20')
    In [33]: vlans
    Out[33]: ['10', '30', '100-200']
    
index() - метод для определения под каким номером в списке находится указанный элемент:

    In [35]: vlans = ['10', '20', '30', '100-200']
    
    In [36]: vlans.index('30')
    Out[36]: 2
    
insert() - метод, позволяющий вставить элемент на определенное место в списке:

    In [37]: vlans = ['10', '20', '30', '100-200']
    
    In [38]: vlans.insert(1, '15')
    
    In [39]: vlans
    Out[39]: ['10', '15', '20', '30', '100-200']
    
sort() - сортирует список на месте:

    In [40]: vlans = [1, 50, 10, 15]
    
    In [41]: vlans.sort()
    
    In [42]: vlans
    Out[42]: [1, 10, 15, 50]	

=========================================================



=== Словарь (Dictionary) ================================

Словари - это изменяемый упорядоченный тип данных:
    • данные в словаре - это пары ключ: значение
    • доступ к значениям осуществляется по ключу, а не по номеру, как в списках
    • данные в словаре упорядочены по порядку добавления элементов
    • так как словари изменяемы, то элементы словаря можно менять, добавлять, удалять
    • ключ должен быть объектом неизменяемого типа: число, строка, кортеж
    • значение может быть данными любого типа
    
    london = {'name': 'London1', 'location': 'London Str', 'vendor': 'Cisco'}

    london = {
	'id': 1,
	'name': 'London',
	'it_vlan': 320,
	'user_vlan': 1010,
	'mngmt_vlan': 99,
	'to_name': None,
	'to_id': None,
	'port': 'G1/0/11'
    }

    In [2]: london['name']
    Out[2]: 'London1'

    In [3]: london['location']
    Out[3]: 'London Str'

Добавить новую пару ключ-значение:

    In [4]: london['vendor'] = 'Cisco'
    
    In [5]: print(london)
    {'vendor': 'Cisco', 'name': 'London1', 'location': 'London Str'}

В словаре в качестве значения можно использовать словарь:

    london_co = {
	'r1': {
	    'hostname': 'london_r1',
	    'location': '21 New Globe Walk',
	    'vendor': 'Cisco',
	    'model': '4451',
	    'ios': '15.4',
	    'ip': '10.255.0.1'
	    },
	'r2': {
	    'hostname': 'london_r2',
	    'location': '21 New Globe Walk',
	    'vendor': 'Cisco',
	    'model': '4451',
	    'ios': '15.4',
	    'ip': '10.255.0.2'
	    },
	'sw1': {
	    'hostname': 'london_sw1',
	    'location': '21 New Globe Walk',
	    'vendor': 'Cisco',
	    'model': '3850',
	    'ios': '3.6.XE',
	    'ip': '10.255.0.101'
	    }
    }

Получить значения из вложенного словаря:

    In [7]: london_co['r1']['ios']
    Out[7]: '15.4'
    
    In [8]: london_co['r1']['model']
    Out[8]: '4451'
    
    In [9]: london_co['sw1']['ip']
    Out[9]: '10.255.0.101'

Функция sorted() сортирует ключи словаря по возрастанию и возвращает новый список с отсортированными ключами:

    In [1]: london = {'name': 'London1', 'location': 'London Str', 'vendor': 'Cisco'}
    In [2]: sorted(london)
    Out[2]: ['location', 'name', 'vendor']

clear() - метод позволяет очистить словарь:

    In [1]: london = {'name': 'London1', 'location': 'London Str'}
    In [2]: london.clear()
    In [3]: london
    Out[3]: {}

copy() - метод позволяет создать полную копию словаря:

    In [10]: london = {'name': 'London1', 'location': 'London Str', 'vendor': 'Cisco'}
    
    In [11]: london2 = london.copy()
    
    In [14]: london['vendor'] = 'Juniper'
    
    In [15]: london2['vendor']
    Out[15]: 'Cisco'

get() - метод запрашивает ключ и в случае его отсутствия возвращает None:

    In [18]: london = {'name': 'London1', 'location': 'London Str', 'vendor': 'Cisco'}
    
    In [19]: print(london.get('ios'))
    None

    Указать другое значение вместо None:
    
    In [20]: print(london.get('ios', 'Ooops'))
    Ooops
    
setdefault() - метод ищет ключ, и если его нет, вместо ошибки создает ключ со значением None:

    In [21]: london = {'name': 'London1', 'location': 'London Str', 'vendor': 'Cisco'}
    
    In [22]: ios = london.setdefault('ios')
    
    In [23]: print(ios)
    None

    In [24]: london
    Out[24]: {'name': 'London1', 'location': 'London Str', 'vendor': 'Cisco', 'ios': None}
    
Если ключ есть, setdefault возвращает значение, которое ему соответствует:

    In [25]: london.setdefault('name')
    Out[25]: 'London1'

Второй аргумент позволяет указать, какое значение должно соответствовать ключу:

    In [26]: model = london.setdefault('model', 'Cisco3580')
    
    In [27]: print(model)
    Cisco3580
    
Методы keys, values, items:

    In [24]: london = {'name': 'London1', 'location': 'London Str', 'vendor': 'Cisco'}
    
    In [25]: london.keys()
    Out[25]: dict_keys(['name', 'location', 'vendor'])
    
    In [26]: london.values()
    Out[26]: dict_values(['London1', 'London Str', 'Cisco'])
    
    In [27]: london.items()
    Out[27]: dict_items([('name', 'London1'), ('location', 'London Str'), ('vendor', 'Cisco')])

    Все три метода возвращают специальные объекты view, которые отображают ключи, значения и пары ключ-значение словаря соответственно
    Очень важная особенность view заключается в том, что они меняются вместе с изменением словаря
    
    Если нужно получить обычный список ключей, который не будет меняться с изменениями словаря, достаточно конвертировать view в список:
    
    In [33]: list_keys = list(london.keys())
    
    In [34]: list_keys
    Out[34]: ['name', 'location', 'vendor', 'ip']

del - удалить ключ и значение:

    In [35]: london = {'name': 'London1', 'location': 'London Str', 'vendor': 'Cisco'}
    
    In [36]: del london['name']
    
    In [37]: london
    Out[37]: {'location': 'London Str', 'vendor': 'Cisco'}

update - позволяет добавлять в словарь содержимое другого словаря:

    In [38]: r1 = {'name': 'London1', 'location': 'London Str'}
    
    In [39]: r1.update({'vendor': 'Cisco', 'ios':'15.2'})
    
    In [40]: r1
    Out[40]: {'name': 'London1', 'location': 'London Str', 'vendor': 'Cisco', 'ios': '15.2'}
    
    Аналогичным образом можно обновить значения:
    
    In [41]: r1.update({'name': 'london-r1', 'ios':'15.4'})
    
    In [42]: r1
    Out[40]: {'name': 'london-r1', 'location': 'London Str', 'vendor': 'Cisco', 'ios': '15.4'}
    
Варианты создания словаря:

    In [1]: r1 = {'model': '4451', 'ios': '15.4'}

Конструктор dict позволяет создавать словарь несколькими способами:
    
    In [2]: r1 = dict(model='4451', ios='15.4')
    
    In [3]: r1
    Out[3]: {'model': '4451', 'ios': '15.4'}
    
    In [4]: r1 = dict([('model', '4451'), ('ios', '15.4')])
    
    In [5]: r1
    Out[5]: {'model': '4451', 'ios': '15.4'}

    Метод fromkeys() создает словарь с известными ключами, но пока что пустыми значениями:
    
    In [5]: d_keys = ['hostname', 'location', 'vendor', 'model', 'ios', 'ip']
    
    In [6]: r1 = dict.fromkeys(d_keys)
    
    In [7]: r1
    Out[7]:
    {'hostname': None,
     'location': None,
     'vendor': None,
     'model': None,
     'ios': None,
     'ip': None}
    
    или одинаковыми значениями:
    
    In [8]: router_models = ['ISR2811', 'ISR2911', 'ISR2921', 'ASR9002']
    
    In [9]: models_count = dict.fromkeys(router_models, 0)
    
    In [10]: models_count
    Out[10]: {'ISR2811': 0, 'ISR2911': 0, 'ISR2921': 0, 'ASR9002': 0}

=========================================================



=== Кортеж (Tuple) ==========================================

Кортеж - последовательность элементов, которые разделены между собой запятой и заключены в скобки, неизменяемый упорядоченный тип данных

Создать пустой кортеж:

    In [1]: tuple1 = tuple()
    
    In [2]: print(tuple1)
    ()
    
Кортеж из одного элемента (обратите внимание на запятую):

    In [3]: tuple2 = ('password',)

Кортеж из списка:

    In [4]: list_keys = ['hostname', 'location', 'vendor', 'model', 'ios', 'ip']
    
    In [5]: tuple_keys = tuple(list_keys)
    
    In [6]: tuple_keys
    Out[6]: ('hostname', 'location', 'vendor', 'model', 'ios', 'ip')

К объектам в кортеже можно обращаться, как и к объектам списка, по порядковому номеру:
    
    In [7]: tuple_keys[0]
    Out[7]: 'hostname'
    
    Но так как кортеж неизменяем, присвоить новое значение нельзя
    
Функция sorted сортирует элементы кортежа по возрастанию и возвращает новый список с отсортированными элементами:

    In [2]: tuple_keys = ('hostname', 'location', 'vendor', 'model', 'ios', 'ip')
    
    In [3]: sorted(tuple_keys)
    Out[3]: ['hostname', 'ios', 'ip', 'location', 'model', 'vendor']

========================================================



=== Множество (Set) ====================================

Множество - это изменяемый неупорядоченный тип данных. В множестве всегда содержатся только уникальные элементы.

С помощью множества можно легко убрать повторяющиеся элементы:

    In [1]: vlans = [10, 20, 30, 40, 100, 10]
    
    In [2]: set(vlans)
    Out[2]: {10, 20, 30, 40, 100}
    
    In [3]: set1 = set(vlans)
    
    In [4]: print(set1)
    {40, 100, 10, 20, 30}
    
add() - метод добавляет элемент во множество:

    In [1]: set1 = {10,20,30,40}
    
    In [2]: set1.add(50)
    
    In [3]: set1
    Out[3]: {10, 20, 30, 40, 50}
    
discard() - метод позволяет удалять элементы, не выдавая ошибку, если элемента в множестве нет:

    In [3]: set1
    Out[3]: {10, 20, 30, 40, 50}
    
    In [4]: set1.discard(55)
    
    In [5]: set1
    Out[5]: {10, 20, 30, 40, 50}
    
    In [6]: set1.discard(50)
    
    In [7]: set1
    Out[7]: {10, 20, 30, 40}
    
clear() - метод очищает множество:

    In [8]: set1 = {10,20,30,40}
    
    In [9]: set1.clear()
    
    In [10]: set1
    Out[10]: set()
    
Объединение множеств можно получить с помощью метода union() или оператора |:

    In [1]: vlans1 = {10,20,30,50,100}
    
    In [2]: vlans2 = {100,101,102,102,200}
    
    In [3]: vlans1.union(vlans2)
    Out[3]: {10, 20, 30, 50, 100, 101, 102, 200}
    
    In [4]: vlans1 | vlans2
    Out[4]: {10, 20, 30, 50, 100, 101, 102, 200}

Пересечение множеств можно получить с помощью метода intersection() или оператора &:

    In [5]: vlans1 = {10,20,30,50,100}
    
    In [6]: vlans2 = {100,101,102,102,200}
    
    In [7]: vlans1.intersection(vlans2)
    Out[7]: {100}
    
    In [8]: vlans1 & vlans2
    Out[8]: {100}
    
Варианты создания множества:

    Пустое множество можно создать таким образом:
    
    In [3]: set2 = set()
    
    In [4]: type(set2)
    Out[4]: set
    
    Множество из строки:

    In [5]: set('long long long long string')
    Out[5]: {' ', 'g', 'i', 'l', 'n', 'o', 'r', 's', 't'}
    
    Множество из списка:
    
    In [6]: set([10, 20, 30, 10, 10, 30])
    Out[6]: {10, 20, 30}

========================================================



=== Функции преобразования типов ===============================

int - преобразует строку в int:

    In [1]: int("10")
    Out[1]: 10
    
    Преобразование числа в двоичной записи в десятичную (двоичная запись должна быть в виде строки):
    
    In [2]: int("11111111", 2)
    Out[2]: 255
    
bin - преобразовать десятичное число в двоичный формат:

    In [3]: bin(10)
    Out[3]: '0b1010'
    
    In [4]: bin(255)
    Out[4]: '0b11111111'

hex - преобразовать десятичное число в шестнадцатеричный формат:

    In [5]: hex(10)
    Out[5]: '0xa'
    
    In [6]: hex(255)
    Out[6]: '0xff'
    
list - преобразует аргумент в список:

    In [7]: list("string")
    Out[7]: ['s', 't', 'r', 'i', 'n', 'g']
    
    In [8]: list({1, 2, 3})
    Out[8]: [1, 2, 3]
    
    In [9]: list((1, 2, 3, 4))
    Out[9]: [1, 2, 3, 4]

set - преобразует аргумент в множество (получить уникальные элементы в последовательности):

    In [10]: set([1, 2, 3, 3, 4, 4, 4, 4])
    Out[10]: {1, 2, 3, 4}
    
    In [11]: set((1, 2, 3, 3, 4, 4, 4, 4))
    Out[11]: {1, 2, 3, 4}
    
    In [12]: set("string string")
    Out[12]: {' ', 'g', 'i', 'n', 'r', 's', 't'}
    
tuple - преобразует аргумент в кортеж (получить неизменяемый объект):

    In [13]: tuple([1, 2, 3, 4])
    Out[13]: (1, 2, 3, 4)
    
    In [14]: tuple({1, 2, 3, 4})
    Out[14]: (1, 2, 3, 4)
    
    In [15]: tuple("string")
    Out[15]: ('s', 't', 'r', 'i', 'n', 'g')

str - преобразует аргумент в строку:

    In [16]: str(10)
    Out[16]: '10'

========================================================



=== Проверка типов =====================================


========================================================

